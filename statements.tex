\Chapter{Statements}{stmt}

A \SpecDef{statement} is an entity in the abstract syntax that describes actions to be taken by a thread.
Statements are executed for their effect, rather than evaluated to produce a value.

\begin{Syntax}
	\SynDefine{Statement} \\
		\SynRef{ExpressionStatement} \\
		\SynOr \SynRef{DeclarationStatement} \\
		\SynOr \SynRef{BlockStatement} \\
		\SynOr \SynRef{EmptyStatement} \\
		\SynOr \SynRef{IfStatement} \\
		\SynOr \SynRef{SwitchStatement} \\
		\SynOr \SynRef{CaseStmt} \\
		\SynOr \SynRef{ForStatement} \\
		\SynOr \SynRef{WhileStatement} \\
		\SynOr \SynRef{DoWhileStatement} \\
		\SynOr \SynRef{BreakStatement} \\
		\SynOr \SynRef{ContinueStatement} \\
		\SynOr \SynRef{ReturnStatement} \\
		\SynOr \SynRef{DiscardStatement} \\
		\SynOr \SynRef{LabeledStatement} \\
\end{Syntax}

\Section{Expression Statement}{expr}

\begin{Syntax}
	\SynDefine{ExpressionStatement} \\
		\SynRef{Expression} \code{;}
\end{Syntax}

An \SpecDef{expression statement} evaluates an expression, and then ignores the resulting value.
An implementation may diagnose a warning when evaluating the expression of an expression statement cannot have side effects.

\begin{Checking}

\SynthJudgement{\ContextVarA}{\MetaVar{E}}{\code{T}}{\ContextVarB} \\
\CheckStmt{\ContextVarA}{\MetaVar{E} \code{;}}{\ContextVarB}

\end{Checking}

\Section{Declaration Statement}{decl}

\begin{Syntax}
	\SynDefine{DeclarationStatement} \\
		\SynRef{Declaration}
\end{Syntax}

A \SpecDef{declaration statement} introduces whatever bindings the \SynRef{Declaration} declares into the current scope.

The following types of declarations may be used in a declaration statement:

\begin{itemize}
\item \SynRef{VariableDeclaration}
\end{itemize}

\begin{Checking}

\CheckDecl{\ContextVarA}{\MetaVar{D}}{\ContextVarB} \\
\CheckStmt{\ContextVarA}{\MetaVar{D} \code{;}}{\ContextVarB}

\end{Checking}

\Section{Block Statement}{block}

\begin{Syntax}
	\SynDefine{BlockStatement} \\
		\lstinline|{| \SynRef{Statement}\SynStar \lstinline|}|
\end{Syntax}

A block statement extends the current environment with a fresh scope,
and then executes each of its constituent statements in order.
The output environment is the input environment.

\begin{Note}
Declarations in a block statement are visible to later statements in the same block, but not to earlier statements in the block, or to code outside the block.
\end{Note}

\begin{Checking}

	\CheckStmt{\ContextVarA}{ \MetaVar{S}... }{\ContextVarB} \\
	\CheckStmt{\ContextVarA}{ \lstinline|lcurly| \MetaVar{S}... \lstinline|rcurly| }{\ContextVarA} \\

	.\\

	\CheckStmt{\ContextVarA}{ \MetaVar{S} }{\ContextVarB} \\
	\CheckStmt{\ContextVarB}{ \MetaVar{T}... }{\ContextVarC} \\
	\CheckStmt{\ContextVarA}{ \MetaVar{S} \MetaVar{T}... }{\ContextVarC} \\

\end{Checking}

\Section{Empty Statement}{empty}

A single semicolon (\Char{;}) may be used as an empty statement equivalent to an empty block statement \Char{\{}\Char{\}}.

\begin{Syntax}
	\SynDefine{EmptyStatement} \\
		\code{;}
\end{Syntax}

Executing an empty statement has no effect.

\begin{Checking}

	\CheckStmt{\ContextVarA}{ \code{;} }{\ContextVarA}

\end{Checking}

\Section{Conditional Statements}{cond}

\SubSection{If Statement}{if}

An \SpecDef{if statement} consists of the \code{if} keyword and a conditional expression in parentheses, followed by a statement to execute if the condition is true:

\begin{codeblock}
if(somethingShouldHappen)
    doSomething();
\end{codeblock}

An if statement may optionally include an \SpecDef{else clause} consisting of the keyword \code{else} followed by a statement to execute if the condition is false:

\begin{codeblock}
if(somethingShouldHappen)
 	doSomething();
else
	doNothing();
\end{codeblock}

\begin{Syntax}
	\SynDefine{IfStatement} \\
		\code{if} \code{(} \code{Condition} \code{)} \\
		\SynRef{ThenClause} \\
		\SynRef{ElseClause}\SynOpt

	\SynDefine{Condition} \\
		\SynRef{Expression}
		\SynOr \SynRef{LetDeclaration}
		
	\SynDefine{ThenClause} \\
		\SynRef{Statement}

	\SynDefine{ElseClause} \\
		\code{else} \SynRef{Statement}
\end{Syntax}

An \SpecDef{\kw{if} statement} executes a sub-statement conditionally.

If the condition of an \kw{if} statement is an expression, then it is evaluated against an expected type of \code{Bool} to yield a value \MetaVar{C}.
If \MetaVar{C} is \code{true}, then the \SynRef{ThenClause} is executed.
If \MetaVar{C} is \code{false} and there is a \SynRef{ElseClause}, then it is executed.

If the condition of an \kw{if} statement is a \kw{let} declaration, then that declaration must have an initial-value expression.
That initial-value expression is evaluated against an expected type of \lstinline[style=SlangCodeStyle]|Optional<$\MetaVar{T}$>|, where \MetaVar{T} is a fresh type variable, to yield a value \MetaVar{D}.
If \MetaVar{D} is \lstinline[style=SlangCodeStyle]|Some($\MetaVar{C}$)|, then the \SynRef{ThenClause} is executed, in an environment where the name of the \kw{let} declaration is bound to \MetaVar{C}.
If \MetaVar{D} is \code{null} and there is a \SynRef{ElseClause}, then it is executed.

\begin{Checking}

\CheckJudgement{\ContextVarA}{\code{c}}{\code{Bool}}{\ContextVarB} \\
\CheckStmt{\ContextVarB}{\MetaVar{T}}{\ContextVarC} \\
\CheckStmt{\ContextVarB}{\MetaVar{E}}{\ContextVarD} \\
\CheckStmt{\ContextVarA}{\code{if(c)} \MetaVar{T} \code{else} \MetaVar{E}}{\ContextVarA}

\end{Checking}

\SubSection{Switch Statement}{switch}

A \SpecDef{switch statement} consists of the \code{switch} keyword followed by an expression wrapped in parentheses and a \SpecDef{body statement}:

\begin{Syntax}
	\SynDefine{SwitchStatement} \\
		\code{switch} \code{(} \code{Expression} \code{)} \\
		\lstinline|{| \SynRef{SwitchAlternative} \lstinline|}|

	\SynDefine{SwitchAlternative} \\
		\SynRef{SwitchAlternativeLabel}\SynPlus \SynRef{Statement}\SynPlus

	\SynDefine{SwitchAlternativeLabel} \\
		\SynRef{CaseClause}
		\SynOr{DefaultClause}
	
	\SynDefine{CaseClause} \\
		\code{case} \SynRef{Expression} \code{:}
	
	\SynDefine{DefaultClause} \\
		\code{default} \code{;}
\end{Syntax}

A \SpecDef{\kw{switch} statement} conditionally executes up to one of its \SpecDef{alternatives}, based on the value of an expression.

It is an error for a case label or default label to appear anywhere other than the body of a \code{switch} statement.
It is an error for a statement to appear inside the body of a \code{switch} statement that is no part of a switch case clause.

Each switch case clause must exit the \code{switch} statement via a \code{break} or other control transfer statement.
"Fall-through" from one switch case clause to another is not allowed.

\Section{Loop Statements}{loop}

\SubSection{For Statement}{for}

A \SpecDef{for statement} uses the following form:

\begin{codeblock}
for( <initial statement> ; <condition expression> ; <side effect expression> ) <body statement>
\end{codeblock}

The \SpecDef{initial statement} is optional, but may declare a variable whose scope is limited to the for statement.

The \SpecDef{condition expression} is optional. If present it must be an expression that can be coerced to type \code{bool}. If absent, a true value is used as the condition.

The \SpecDef{side effect expression} is optional. If present it will executed for its effects before each testing the condition for every loop iteration after the first.

The \SpecDef{body statement} is a statement that will be executed for each iteration of the loop.

\SubSection{While Statement}{while}

A \SpecDef{while statement} uses the following form:

\begin{codeblock}
while( <condition expression> ) <body statement>
\end{codeblock}

and is equivalent to a \code{for} loop of the form:

\begin{codeblock}
for( ; <condition expression> ; ) <body statement>
\end{codeblock}

\SubSection{Do-While Statement}{dowhile}

A \SpecDef{do-while statement} uses the following form:

\begin{codeblock}
do <body statement> while( <condition expression> )
\end{codeblock}

and is equivalent to a \code{for} loop of the form:

\begin{codeblock}
for(;;)
{
	<body statement>
	if(<condition expression>) continue; else break;
}
\end{codeblock}

\Section{Control Transfer Statements}{control}

\SubSection{Break Statement}{break}

A \code{break} statement transfers control to after the end of the closest lexically enclosing switch statement or loop statement:

\begin{codeblock}
break;
\end{codeblock}

\SubSection{Continue Statement}{continue}

A \code{continue} statement transfers control to the start of the next iteration of a loop statement.
In a for statement with a side effect expression, the side effect expression is evaluated when \code{continue} is used:

\begin{codeblock}
break; 
\end{codeblock}

\SubSection{Return Statement}{continue}

A \code{return} statement transfers control out of the current function.

In the body of a function with a \code{void} result type, the \code{return} keyword may be followed immediately by a semicolon:

\begin{codeblock}
return;
\end{codeblock}

Otherwise, the \code{return} keyword must be followed by an expression to use as the value to return to the caller:

\begin{codeblock}
return someValue;
\end{codeblock}

The value returned must be able to coerce to the result type of the lexically enclosing function.

\SubSection{Discard Statement}{discard}

A \code{discard} statement can only be used in the context of a fragment shader, in which case it causes the current invocation to terminate and the graphics system to discard the corresponding fragment so that it does not get combined with the framebuffer pixel at its coordinates.

Operations with side effects that were executed by the invocation before a \code{discard} will still be performed and their results will become visible according to the rules of the platform.
